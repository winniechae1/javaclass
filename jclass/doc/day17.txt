# day17

Object 클래스
==> 자바로 만든 클래스들의 최상위 클래스 역할을 하는 클래스이다.
	특별히 하는일은 별로 없고
	자바 상속 관계를 명확하게 하기 위한 역할로 주로 사용이 된다.
	
	1. equals()
		==> 비교 함수이다.
			문제는 Object가 가지고 잇는 이 함수는 내용을 비교하는 함수가 아니고
			주소를 비교하는 함수이다.
			연산자중 동등비교연산자와 같은 기능을 가지고 있는 함수이다.
			
		참고 ]
			우리가 String 타입의 데이터를 비교할 때 equals()를 사용해서
			데이터를 비교했었는데..
			이것은 String 이 Object의 equals()를 오버라이드하여
			기능을 데이터를 비교하는 기능으로
			변경시켜 놓은 것이다.
			
		참고 ]
			만약 우리가 제작하는 클래스도 내용 비교를 하도록 원하면
			이 함수를 오버라이드해서 기능을 수정하면 된다.
			
-----------------------------------------------------------------------------------------
사용자 정의 예외 클래스 만들기
==> 예외 클래스는 예외의 발생 원인을 알려주는 역할을 담당한다.
	그런데 어제 강제 예외던지기는 자바가 준비한 예외클래스들만 처리할 수 있다.
	
	만약 우리가 정의한 예외클래스가 있다라고 한다면
	예외의 원인을 파악해주도록 클래스를 작성해야 할 것이다.
	
	사용자 정의 예외클래스는 사용자가 지정한 예외클래스이고
	이 클래스로 예외처리를 할 경우에는 반드시 예외의 원인을 알려주도록 작성해야 하는데
	
	방법 ]
		1. Exception 클래스를 상속 받은 클래스를 제작한다.
		2. toString() 를 오버라이드해서
			예외의 원인을 출력할 수 있도록 한다.
-----------------------------------------------------------------------------------------
String 클래스
==> 문자열을 관리하는 클래스
	
	***
	주의사항 ]
		 String 클래스의 가장 큰 단점
		 ==> String 클래스는 내용이 변경이되면
		 		변경된 내용을 다시 메모리에 저장하고
		 		주소를 다시 저장된 메모리의 주소로 바꾼다.
		 		
		 따라서 String 의 내용변화가 심하면 메모리를 계속해서 누적해서 사용하게 된다.
		 한마디로 메모리의 낭비가 심해진다.
		 
		 그러므로
		 변경이 잦은 문자열은 StringBuffer 또는 StringBuilder 클래스를 사용해서
		 처리하는 것이 좋다.
		 
		참고 ]
			그래도 간단한 문자열 처리는 자주 사용하는 클래스이므로
			"클래스 중 유일하게" new 시키지 않고 사용할 수 있도록 준비해 놓은 클래스이다.
			
			String str1 = new String("홍길동");
			String str2 = "홍길동";
			==> 두가지모두 가능하도록 해 놓았다.
			
		참고 ]
			String 클래스는 클래스 중 유일하게
			+ 연산자를 사용가능하도록 해놓았다.
			
----------------------------------------------------------------------------------------------------
오버라이드 규칙
	
	0.	상속을 받아야 한다.
	1.	함수의 원형을 유지해야 한다.
	2.	접근 지정자는 같거나 넓은 방향으로 해야 한다.
	3.	예외처리(예외전이)는 같거나 좁은 방향으로 처리해야 한다.
	
예 ]
	void add(int a, int b) throws InvalidNumberException, NotANumberException {
	}
	
	==> 오버라이드 할때는
	void add(int a, int b) throws InvalidNumberExceptionm, NotANumberException {
	}	==> O
	
	void add(int a, int b) throws InvalidNumberException {
	}	==> O
	void add(int a, int b) throws NotANumberException {
	}	==> O
	
	void add(int a, int b) throws Exception {
	}	==> X : 예외의 범위가 더 넓은 방향으로 예외전이를 하도록 하는 오버라이드는 불가능하다.
	
----------------------------------------------------------------------------------------------------
StringBuffer
==> String 과 동일하게 문자열을 관리하는 클래스이다.
	
	***
	차이점
		String 클래스는 내용이 변화되면 새로운 메모리를 다시 확보하고
		변화된 내용은 다시 기억한 후 주소를 바꾼다.
		==> String 클래스는 잦은 변화가 생기면 메모리가 많이 소모된다.
		
		StringBuffer는 String의 문제점을 해결하기 위해서
		만들어 놓은 또 하나의 문자열을 관리하는 클래스로
		내용 변화가 있으면 현재 메모리에 변화된 내용을 그대로 기억한다.
		
		StringBuffer는 String과는 다르게
			대입연사자( = )
		를 사용해서 문자열을 기억하는 것은 불가능하고
		반드시 객체지향 원리에 따라서
		반드시 new 시켜서 사용해야 한다.
		
		StringBuffer str = "Hong";						-----> error
		StringBuffer str = new StringBuffer("Hong");	-----> success
		
	참고 ]
		String str = "Hong";
		str = str + "Gil";
		즉 + 연산자를 이용해서 문자열을 결합하는 것 역시
		오직 String 클래스에 한해서 허락한 문법이다.
		
		나머지 클래스는 반드시 그 클래스가 가진 기능(함수)를
		이용해서 필요한 처리를 해줘야 한다.
		
		StringBuffer str = new StringBuffer("Hong");
		str.append(" Gil"); // 원래 기억하던 문자열에 다른 문자열을 결합하는 기능의 함수(append())
		
	참고 ]
		실무에서의 StringBuffer 활용방법
			1. String 이 편리하므로 String 으로 먼저 처리한다.(먼저 만든다.)
				String str = "Hong";
				
			2. 문자열의 변화가 일어나는 시점이 되면
				그순간 StringBuffer 타입으로 변환시킨다.
				
				StringBuffer buff = new StringBuffer(str);
			
			3. StringBuffer 를 이용해서 문자열 변화를 시도한다.
				==> 이때 메모리가 낭비되는 현상이 일어나지 않는다.
				
			4. 문자열 변화가 종료되면 다시 자주 편하게 사용하는 String 클래스 타입으로
				변환시킨다.
					
					str = new string(buff);
					또는
					str = buff.toString();
		
	참고 ]
		StringBuilder
		==> 이 클래스 역시 StringBuffer와 동일한 역할을 하는 클래스이다.
		
			주로 Thread 처리를 할 때 동기화에 대해서 안정적으로 처리가 가능하다.

----------------------------------------------------------------------------------------------------
숙제 ]
	String, StringBuffer, StringBuilder
	클래스가 가지고 있는 주요함수 5개를 조사해서 본인에게 제출하세요.
		내용은 함수의 의미와 사용예제를 만들어보세요.

----------------------------------------------------------------------------------------------------

