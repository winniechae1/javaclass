# day14

멤버변수의 초기화
==>	멤버변수(Field)는 Heap 영역에 생기므로 자동 초기화가 된다. 
	하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.
	
1.	명시적 초기화
==>	변수를 선언하면서 값을 입력하는 방법
	가장 먼저 실행되는 방법
예]
	class Test{
		int num = 100; // 명초
	}
		
2.	초기화 블럭을 이용한 초기화
==>	인스턴스 변수에 대해서만 가능한 것으로 두번째로 실행되는 방법
예]
	class Test{
		int num;
		...
		{
			이곳에 데이터를 변수에 입력 
			num = 10;	// 초기화 블럭
		}
	}
	
3.	static 블럭을 이용한 초기화
==>	2번과 반대로 static 변수에 한해서만 가능한 방법
	두번째로 실행되는 방법 
예]
	class Test{
		static int num;
		...
		static {	--static 블럭
			num = 50;
		}
	}
	
4.	생성자 함수를 이용한 초기화
==>	가장 마지막에 실행되는 방법
예]	
	class Test{
		int num;
		
		public Test(){
			num = 200;
		}
	}
	
----------------------------------------------------------------------------
객체지향언어

1.	상속
2.	다형성
3.	은닉화/캡슐화	: 변수는 다른 클래스에서 접근하지 못하도록 하고 데이터를 꺼내거나 
					  입력하는 작업은 함수를 만들어서 처리하도록 하는 방법

--------------------------------------------------------------------------------------
상속
==> 이미 만들어진 클래스의 기능을 그대로 부여받아서(==>변수와 함수의 기능을 그대로 복사
	받아서) 새로운 클래스를 만드는 방법
	
이 개념이 나온 이유는 소프트웨어의 개발 속도를 빠르게 하기 위한 한가지 방법이다.
즉, 상속은 객체지향에서 매우 중요한 역할을 하는 것으로 객체지향언어는 부품 단위 
(class)로 프로그램을 만든 후 그 부품을 조립해서 원하는 결과를 얻어내는 것이다.

어디서 부품(클래스)을 구했는데 그 기능이 사용자 마음에 꼭 맞지 않을 수도 있다. 그러면
처음부터 다시 만들어야 하는가? 하는 문제에서 이 문제점을 해결하기 위해서 만든 방법이 상속이다.

상속은 자신이 만들고자 하는 부품과 가장 유사한 부품을 가지고 와서 일단 그 기능을 모두 복사한 후 
1. 없는 기능은 덧붙이고 
2. 있는 기능 중 바꿀내용만 바꾸자. 라는 것이 상속이다.

-------------------------------------------------------------------------------------------------
***
상속의 형식]
	[접근지정자] [속성] class 클래스이름	extends	상속해줄 클래스이름 {
		이 안에는 우리 눈에 안보이더라도 상속해줄 클래스의 멤버들이 모두 포함되어있다.
	} 
==>	따라서 상속을 받아서 만드는 클래스는 상속해주는 클래스보다 멤버(변수, 함수)가 늘어난다.

참고]
	자바는 오직 단일 상속만 가능하다.
==>	상속해주는 클래스는 한개여야만 한다.

예]
	class NewClass extends Old01, Old02 {
	
	}	-- X

	class NewClass extends Old01{
		
	}	-- O
	
용어정리]

상속을 해준 클래스 : super Class , 상위클래스, 부모클래스
상속을 받은 클래스 : sub Class, 하위클래스, 자식클래스

is a	==> 상속 관계에 있는 클래스를 부르는 용어
			class Father{}
			class Son extends Father{}
			
			이 경우 
			Son is a Father
			가 성립된다.

has a  	==> 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
			class Father{}
			class Son{
				Father f = new Father();
			}
			이 경우 
				Son has a Father 가 성립한다.
				
-------------------------------------------------------------------------------
상속 관계에 있는 경우 생성자의 역할

결론]
	하위클래스가 생성되는 순간 
	상위클래스가 자동 생성된다.
	==> 생성되는 순간 생성자 함수가 호출되므로 결국 하위클래스를 생성하면 
		상위클래스의 생성자 함수도 실행된다.
결론적으로 상위 클래스의 생성자 함수는 자동으로 호출되는 개념이다.
자동 호출되는 경우는 무조건 기본 생성자만 이용하게 된다.
참고]
	기본생성자 : 매개변수가 없는 생성자 

**
참고]
	super()	상위클래스의 특별한 생성자를 강제로 호출하는 기능을 가진 명령
특징]
	

	
-------------------------------------------------------------------------------
***
함수의 오버라이딩(Overriding : 함수의 재정의)
==> 상속관계에 있는 하위 클래스에서 상위클래스가 가진 함수의 기능을 수정하는 행위

방법]
0.	상속을 받아야한다.
1.	상위클래스가 가진 함수의 원형과 동일한 원형으로 만들어야 한다. 
참고]
	함수의 원형(Prototype)
	반환값 타입 + 함수이름 + 매개변수리스트
2.	접근지정자는 같거나 넓은 방향으로 한다.
3.	예외처리는 같거나 좋은 방향으로 한다. 

이렇게 오버라이딩을 하면 
내부적으로 super의 함수가 숨겨지고 재정의한 함수가 사용된다.

예]
	class Father {
		void abc(int a){
		}
	}
	class Son extends Father{
		void abc(int a){
			함수 내용 수정  
			==> 기능을 변경  
		}
	}

*****
참고]
super 
==> this가 실행중인 객체 자기자신을 기억하는 예약된 변수이듯이 
	super 역시 예약된 변수 중 하나로 자신의 상위클래스의 주소가 
	기억된 변수

사용목적]
	반드시 상위클래스의 멤버임을 밝혀야하는 경우가 생길 때 사용한다.
	
*****
참고]
	상속관계에 있는 클래스에서 
	함수는 인스턴스 쪽을 따르고 
	변수는 레퍼런스 쪽을 따른다.
	
	
	
	
	
	
	
	
---------------------------------------------------------------------------------
package 와 import

package 
자바 프로그램 소스코드가 들어있는 폴더를 자바에서 부르는 용어

자바는 오픈소스이다. 모든 사람이 자신이 만든 프로그램을 제공할 수 있고 
그것을 모든 사람이 이용할 수 있는 프로그램이다. 그러다보니 문제점이 클래스이름이 
충돌이 날 수 있다. 
이런 문제를 해결하기위해서 만들어 놓은 방법이 패키지이다. 
즉. 소스코드를 만드는 사람이 그 프로그램이 포함되는 폴더이름 까지 정해서 프로그램을 
만들도록 하는 것
결론적으로 자바로 프로그램을 만들 때는 반드시 해당 프로그램이 어떤 폴더에 저장되는지를
알려주도록 해 놓았다. 

명령]
	package 폴더이름;
	
참고]
	패키지이름을 만드는 권장 사항 
	자신이 사용하는 도메인을 거꾸로 쓴 후 그 다음에 다시 폴더이름을 붙여서 사용하세요.
예]
	increpas.com
==>	com.increpas.day14

-----------------------------------------------------------------------------------------
import 
자신이 사용할 클래스가 어떤 폴더(패키지) 소속의 클래스인지를 밝혀주기 위한 명령
예]
	package sample
			Test.class
			
	package test
			Test.class

형식1]
	import		패키지경로.클래스이름;
==>	지정한 폴더에 있는 클래스를 사용할 예정임을 밝히는 것.

형식2]
	import		패키지경로.*;
==>	지정한 폴더에 있는 모든 클래스를 사용할 준비를 해두는 것.

참고]
	형식2 보다는 형식1을 우선시 한다.

참고]
	import 하지 않아도 명시적으로 클래스이름 앞에 패키지 이름을 붙여서 사용할 수 있다.

---------------------------------------------------------------------------------------------
참고]
	유일하게 java.lang 패키지는 import 시키지 않아도 사용할 수 있다. 
	?? JVM이 기본적으로 찾아보는 패키지이기 때문이다.
주의]
	import를 하게 되면 해당 패키지만 선언하게 되는 것이다.
	그 상위나 하위는 포함되지 않는다.
	
	package1 -------------T1
				  |-------T2
	        	  |-------T3
	        	  |-------package2 ------------Q1
	        	  						|------Q2
	        	  						|------Q3
	import p1.*;
==>	p1 패키지 바로 하위의 클래스들만 사용할 준비를 하는 것이다.
	p2 패키지 소속의 클래스들은 사용할 준비를 안하는 것이다.
	
static import
==>	staic 멤버는 원칙적으로 < 클래스이름.멤버 >의 형식으로 사용해야 한다.
예]	
	Math.random();
	Math.PI;

static 멤버 앞에 사용하는 클래스이름 조차도 생략할 수 있다.
==>	이처럼 static 멤버를 사용할 때 클래스이름을 생략하도록 하는 방법이 static import 이다.

형식]
	import		static		패키지이름.클래스이름.*;