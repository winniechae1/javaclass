day02

자바프로그램의 토큰 구분 
>> 컴파일러는 토큰 단위로 번역을 시도한다. 
	따라서 개발자는 컴파일러가 번역하는 토큰을 구분해줘야 한다. 
	이것이 ";" 이라는 기호를 이용해서 구분하게 된다. 
	
	우리가 습관적으로 
		int a = 10; 
	이라고 기술한 이유가 토큰을 구분하기 위한 기호였다. 
	
	결론적으로 토큰이란 하나의 명령이 종료되었음을 알려주는 기호이다.
	
	만약 개발자 토큰을 구분하지 않으면 오류가 날 수 있다. 
	
	예]
		int a = 10
		int b = 20;
		>> 컴파일러는 두줄을 하나의 명령으로 인식해서 처리하게 될 것이고 
		       이런 명령형식은 자바에서 존재하지 않으므로 에러가 발생한다.

	예]
		int a = 10; int b = 20;
		>> 한 줄로 입력했지만 두개의 명령으로 인식하여 먼저 
			int a = 10;
		 만 컴파일 하고 
		 	int b = 20;
		 은 따로 컴파일하게 돼서 안전하게 컴파일이 완성이 된다.
	
	참고]
		토큰 기호는 ; 대신 {} 기호가 그 역할을 대신할 수 있다. 
	
	예]
		if(조건식) {
			처리내용
		}
		>> 이 경우 ;은 없지만 } 가 그 역할을 대신하기 때문에 컴파일러는 
			{} 를 별도로 컴파일하게 된다. 
			토큰이 발생했다. 라고 이야기 할 수 있다. 
	
	
참고]
	>> 키보드를 이용해서 데이터를 입력 받기 
		(이 부분은 OOP(객체지향)이론을 먼저 공부한 후 이해할 수 있다.)
		
		1. class가 만들어지기 이전에 
			import java.util.*;
			라는 명령을 이용해서 사용할 라이브러리를 등록한다. 
		2. 프로그램에 들어가는 (주로 main함수 내에서)
			
			Scanner sc = new Scanner(System.in);
			이라는 명령을 이용해서 키보를 통해서 입력받을 도구를 준비한다. 
		
		3. 키보드를 통해서 입력받을 필요가 생기면...
			
			변수 = sc.nextXXX();
		 
		  	명령을 이용해서 데이터를 입력 받으면 된다. 
		  	이때, XXX는 입력받을 데이터의 종류에 따라서 달라진다. 
		  
		  예]
		  	문자열을 입력받고 싶다면 
		  	String str = sc.nextLine();
		  	
		  	정수로 입력받고 싶다면 
		  	int num = sc.nextInt();
		  	
		  	실수를 입력받고 싶다면 
		  	float num = sc.nextFloat();

참고]
	숫자형식의 문자열을 숫자로 변환시키는 방법
	
	예]
		"123"	>> 콘솔화면에서는 숫자로 보이지만 
					실제로는 문자열의 데이터이다. 
					이것은 사칙연산을 할 수 없는 데이터이다. 
		
		이것을 실제 계산이 가능한 숫자로 변환하는 방법 
		
			int no = Integer.parseInt("문자열데이터");
			
			>> int no = Integer.parseInt("123");
				>> 문자열 "123"을 정수 123으로 변환시켜주는 함수 
			
------------------------------------------------------------------------------
문제]
	세 자리 숫자를 입력받아서 100을 뺀 값을 출력해주는 프로그램을 작성하세요.
	 

문제2]
	사각형의 가로와 세로의 길이를 정수로 입력받아서 
	넓이를 출력해주는 프로그램을 작성하세요.

문제3]
	삼각형의 밑변과 높이를 정수로 입력받아서 
	넓이를 출력해주는 프로그램을 작성하세요.
	 
문제4]
	친구의 이름, 나이, 신장, 전화번호를 입력받아서 
	출력해주는 프로그램을 작성하세요.

------------------------------------------------------------------------------

형변환(Casting)
>> 데이터를 사용하다보면 데이터의 형태를 바꿔야 할 필요가 생긴다.
	이처럼 데이터의 형태를 변경하는 것을 "형변환" 이라고 한다.

	1.	자동형변환
		>> 개발자가 지정하지 않아도 자동적으로 형태를 바꿔서 사용되는 경우 
		
		발생하는 경우
		>> 작은 형태의 데이터가 큰 형태의 데이터가 필요한 경우 자동형변환이 이루어진다.
		예]
			float no = 10; 
			>> no 는 float 타입의 실수형 변수이고 10은 정수형 데이터이다. 타입은 int 
				이때, 입력크기로 보자면 두개의 타입 모두 4바이트를 기억할 수 있어서 
				같은 크기이지만 타입이 서로 다른 경우에는 byte로 비교하지 않고 
				항상 실수 데이터가 byte와 무관하게 크다. 
		
		결론적으로 큰 타입의 변수에 작은 타입의 데이터를 대입하는 경우 자동형변환이 발생한다. 
------------------------------------------------------------------------------			
			참고]
				실수는 주어진 비트를 3개의 영역 (부호, 소수, 데이터영역)으로 분리해서 입력된 데이터를
				지수형태의 데이터로 만들어서 각각의 영역에 기억하도록 하는 방식을 사용한다. 
------------------------------------------------------------------------------
			
			따라서 정수와 실수의 연산의 결과는 항상 실수가 된다. 
			
		하지만 만약 
			
			float no = 10.;
			>> 이것은 10. 은 실수 데이터이고 자바에서는 실수데이터의 기본타입이 double 이기 때문에 
				10. 데이터가 변수보다 크기가 크다. 따라서 이 경우에는 에러가 발생한다.  

	2.	강제형변환
		>> 자동형변환이 불가능한 경우 
		   경우에 따라서는 개발자가 강제로 형변환을 해줘야하는 필요가 생긴다.
		   
		형식]
			(변환할 타입) 데이터;
		
		예]
			float no = (float) 10.;
			>> 10. -- double 타입데이터(8바이트)
			   no  -- float 타입데이터(4바이트)
		
		참고]
			강제형변환을 하면 데이터가 손실될 위험이 있다. 
		참고]
			실제데이터 자체는 변함이 없다. 
	
		1, 2번의 경우 공통적으로 사용하는 시점에 형태가 변환된다. 
		
	3.	리터럴형변환
		>> 리터럴 풀에 담기는 데이터의 형태를 변형시키는 방법 
		
		형식]
			정수의 경우 : 데이터L(또는 l)
			실수의 경우 : 데이터F(또는 f)
		
		예]
			float pi = 3.14f;
			
---------------------------------------------------------------------------
사칙연산자
	+	: 더하기
	-	: 빼기
	*	: 곱하기
	/	: 나누기
	%	: 나머지

대입연산자
	=, +=, -=, *=, /=, %= 
	
	기본기호 ]		
			=
	
	형식] 	
		변수 = 데이터; 
	
	의미]
		데이터를 변수에 기억하라.
	
	참고]
		자바의 모든 연산은 반드시 대입연산자가 있어야 기억할 수 있다. 
		만약 대입하지 않으면 연산의 결과는 기억되지 못한다. 
	
	참고]
		모든 연산자는 같은 연산자가 중복된 경우 왼쪽에서 오른쪽으로 진행하면서 계산된다.
		
		예]
			3 + 5 + 7 
			연산 방향이 
			------->
			(3+5) 의 결과를 가지고 다시 +7 연산을 한다. 
			
			하지만 유일하게 대입 연산자만큼은 오른쪽에서 왼쪽으로 진행해서 처리한다. 
			
			int no = 4 + 5; 
			
			산술연산은  ------->
			대입연산은 <-------
			
		참고]
			int a;
			int b;
			int c;
			
			a = b = c = 10;
			
		참고]
			변수선언의 경우 
			같은 타입의 데이터는 , 구분자로 나열해서 선언할 수 있다. 
			
			int a, b, c;
			
			int a, b, c=10;		>> O 

-----------------------------------------------------------------------

연산자의 우선순위 
	>> 하나의 연산식에서 여러 연산자가 혼합된 경우 무엇을 먼저 처리하는가를 정해놓은 규칙
	
	규칙]
		산술 > 비교 > 논리 > 대입
	
	***
	결론]
		대입연산자는 모든 연산이 종료된 후 실행된다. 
		항상 연산이 끝난 후 그 결과가 기억된다. 
		
------------------------------------------------------------------------
증감연산자 
	>> 주기억장치(메모리)에서 직접 연산되는 연산자. 
		대입하지 않아도 변수 자체가 변경되는 연산자.
		
	기호]
		++, --
	의미]
		변수의 데이트를 1씩 증가 또는 감소시키세요.
	참고]
		연산기호를 기준으로 값을 예측하면 된다. 
	예]
		int a = 10;
		
		System.out.println(++a);
		>> 11이 출력된다.
		
		int b = 20;
		System.out.println(b++); 
		>> 20이 출력된다. 
		
		System.out.println(++b);

	주의]
		이 연산자는 다른 연산자와 혼합되어 있는 경우 
		(연산을 해야하는 데이터가 다른 연산자 (명령)에도 사용되는 경우)
		(하나의 식안에 다른 연산자와 증감연산자가 같이 있는 경우)
		(다른 연산자와 실행순서가 달라질 수 있다.)
		
		예]
			b = ++a;
		
		종류]
			선처리 증감 
				형식]
					++변수
					>> 증감을 먼저하고 다른 연산을 나중에 한다. 
			
			후처리 증감
				형식]
					변수++
					>> 다른 연산을 먼저하고 나중에 오는 변수에 1증감한다.

----------------------------------------------------------------
숙제]
	다음 연산 결과를 예측하고 프로그램을 작성해서 예측이 맞는지 확인하세요. 
	맨 마지막에 기억된 변수들의 값을 예측하고 출력하세요.
	
	1) int a = 10;
	   int b = ++a + ++a;
	
	2) int a = 10;
		int b = ++a + a++;
	
	3) int a = 10;
		int b = a++ + a++;
		
---------------------------------------------------------------------
부호 반전 연산자 
	>> 현재의 부호를 반대로 바꾸는 연산자 
		즉, 양수이면 음수로 음수이면 양수로 바꿔주는 연산자.
	
	기호]
		-
	형식]
		-데이터;

-------------------------------------------------------------------
비교 연산자 
	>> 두 데이터의 크기 관계를 비교하는 연산자
		결과값은 boolean 타입으로 데이터 true, false 로 반환해준다. 
		
	기호]
		==	: 같다.
		!=	: 다르다.
		>	: 크다
		<	: 작다
		>=	: 크거나 같다.
		<=	: 작거나 같다.
	
	주의]
		사용되는 데이터와 관계없이 결과는 항상 논리값으로 나온다.
		
	참고]
		이 연산자는 주로 if,...등의 제어 명령에서 질문이 필요할 때 많이 사용되는 연산자이다.
	
	참고]
		문자열은 엄밀히 말해서 일반 데이터가 아니다.
		따라서 문자열은 비교할 때 조심해서 사용해야 한다.
	
	참고]
		문자 데이터도 크기 비교가 가능하다. 
		문자 데이터는 아스키코드값으로 기억되기 때문에 그 코드값으로 대소비교를 하게 된다.
		
--------------------------------------------------------------------------
